## R Programming - Programming Assignment 2
### Testing makeCacheMatrix and cacheSolve functions

To test the functionality and measure the performance of makeCacheMatrix and cacheSolve follow the steps below.


**Clean all variables** from the R programming environment by entering command:

```
>rm(list=ls())
```

Make the source code available to R:

```
>source("cachematrix.R"")
```

**Create the empty matrix:**
```
>x <- makeCacheMatrix(x)
```

**Fill in a matrix** with random numbers:
```
>x$set(matrix(rnorm(1000000), nrow=1000, ncol=1000))
```

The size of this matrix has been chosen large enough to make a substantial difference by caching the result.

For reference **test the "traditional" solution** (no caching):
```
>system.time(x1 <- solve(x$get()))
>  user  system elapsed 
>  0.78    0.00    0.78
```

**Test first time usage**, time slightly longer than "traditional":
```
>system.time(x2 <- cacheSolve(x))
>   user  system elapsed
>   0.81    0.00    0.81
```

If we run again the last command to test the time taken by cacheSolve it shows: 
```
>getting cached data
>   user  system elapsed 
>      0       0       0 
```

The execution time is much shorter than before but we don't have a true measure of it due to the low resolution. We need to increase the measurement resolution by changing the options and using the system clock. 

**Test _cacheSolve_ re-use** (second time and after):
```
>options(digits.secs=6)

>t1 <- Sys.time()
>x3 <- cacheSolve(x)
>Sys.time() - t1
> Time difference of 0.0180011 secs
```

We'll get this result for the second time and after since from now on the program will use cached data.

Make sure the three results are in fact identical:
```
>identical(x1, x2)
>[1] TRUE
>identical(x1, x3)
>[1] TRUE
```

This final step shows that the results provided by the new implementation are identical to the one generated by the traditional inverse based on solve with the added benefit of being much faster *(0.018 sec vs 0.78 sec)* if the inverse has been computed before.
